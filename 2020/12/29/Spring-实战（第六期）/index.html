<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    <link rel="shortcut icon" type='image/x-icon' href="/favicon.ico">


    <!-- meta -->


<title>Spring-实战（第六期） | lianzixin</title>





    <!-- OpenGraph -->
 
    <meta name="description" content="创建 REST 服务应用程序采用了一种常见的设计：将用户界面推近客户端，而服务器公开一个 API，通过该 API，所有类型的客户端都可以与后端进行交互。 编写 RESTful 控制器Spring MVC HTTP 请求处理注解  @GetMapping     HTTP GET 请求 @PostMapping    HTTP POST 请求 @PutMapping     HTTP PUT 请求">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-实战（第六期）">
<meta property="og:url" content="http://lianzixin.github.io/2020/12/29/Spring-%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC%E5%85%AD%E6%9C%9F%EF%BC%89/index.html">
<meta property="og:site_name" content="lianzixin">
<meta property="og:description" content="创建 REST 服务应用程序采用了一种常见的设计：将用户界面推近客户端，而服务器公开一个 API，通过该 API，所有类型的客户端都可以与后端进行交互。 编写 RESTful 控制器Spring MVC HTTP 请求处理注解  @GetMapping     HTTP GET 请求 @PostMapping    HTTP POST 请求 @PutMapping     HTTP PUT 请求">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-12-29T03:59:40.000Z">
<meta property="article:modified_time" content="2020-12-29T03:59:47.098Z">
<meta property="article:author" content="lianzixin">
<meta name="twitter:card" content="summary_large_image">


    
<link rel="stylesheet" href="/css/style/main.css">
 



    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
    

    
    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.2.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">lianzixin</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/categories/" class="navbar-menu button">分类</a>
                
            </div>
        
        
        

        
        

        

        
            <a class="dropdown-icon button" id="btn-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/categories/" class="dropdown-menu button">分类</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        Spring-实战（第六期）
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2020/12/" class="post-meta__date button">
    2020-12-29
</a>
        
    <span class="separate-dot"></span><a href="/categories/spring/" class="button">spring</a>

 
        
    
    


 

 
    </div>
</div>



<article class="post content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <h1 id="创建-REST-服务"><a href="#创建-REST-服务" class="headerlink" title="创建 REST 服务"></a>创建 REST 服务</h1><p>应用程序采用了一种常见的设计：将用户界面推近客户端，而服务器公开一个 API，通过该 API，所有类型的客户端都可以与后端进行交互。</p>
<h2 id="编写-RESTful-控制器"><a href="#编写-RESTful-控制器" class="headerlink" title="编写 RESTful 控制器"></a>编写 RESTful 控制器</h2><p>Spring MVC HTTP 请求处理注解</p>
<ul>
<li><code>@GetMapping</code>     HTTP GET 请求</li>
<li><code>@PostMapping</code>    HTTP POST 请求</li>
<li><code>@PutMapping</code>     HTTP PUT 请求</li>
<li><code>@PatchMapping</code>   HTTP PATCH 请求</li>
<li><code>@DeleteMapping</code>  HTTP DELETE 请求</li>
<li><code>@RequestMapping</code> 通用请求处理</li>
</ul>
<h3 id="从服务器获取数据"><a href="#从服务器获取数据" class="headerlink" title="从服务器获取数据"></a>从服务器获取数据</h3><p><code>@RestController</code>：告诉 Spring，将程序的返回值写入响应体<br><code>@RequestMapping</code>：指定路径前缀，produces 指定只有请求头为指定值才进行处理<br><code>@CrossOrigin</code>：允许来自任何域的客户端使用 API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(path=&quot;/design&quot;, produces=&quot;application/json&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin(origins=&quot;*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TacoRepository tacoRepo;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EntityLinks entityLinks;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DesignTacoController</span><span class="params">(TacoRepository tacoRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tacoRepo = tacoRepo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/recent&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Taco&gt; <span class="title">recentTacos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PageRequest page = PageRequest.of(</span><br><span class="line">            <span class="number">0</span>, <span class="number">12</span>, Sort.by(<span class="string">&quot;createdAt&quot;</span>).descending());</span><br><span class="line">        <span class="keyword">return</span> tacoRepo.findAll(page).getContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 URL 传参的形式获取内容，使用 @PathVariable 注解，并在路径使用 {} 包裹变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Taco <span class="title">tacoById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    Optional&lt;Taco&gt; optTaco = tacoRepo.findById(id);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (optTaco.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> optTaco.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新服务器的资源"><a href="#更新服务器的资源" class="headerlink" title="更新服务器的资源"></a>更新服务器的资源</h3><p>使用 <code>@PostMapping</code> 注解，适合全量更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">putOrder</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> repo.save(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>@PatchMapping</code> 注解，适合部分更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PatchMapping(path=&quot;/&#123;orderId&#125;&quot;, consumes=&quot;application/json&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">patchOrder</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId, </span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="meta">@RequestBody</span> Order patch)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Order order = repo.findById(orderId).get();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (patch.getDeliveryName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        order.setDeliveryName(patch.getDeliveryName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (patch.getDeliveryStreet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        order.setDeliveryStreet(patch.getDeliveryStreet());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (patch.getDeliveryCity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        order.setDeliveryCity(patch.getDeliveryCity());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (patch.getDeliveryState() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        order.setDeliveryState(patch.getDeliveryState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (patch.getDeliveryZip() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        order.setDeliveryZip(patch.getDeliveryState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (patch.getCcNumber() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        order.setCcNumber(patch.getCcNumber());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (patch.getCcExpiration() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        order.setCcExpiration(patch.getCcExpiration());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (patch.getCcCVV() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        order.setCcCVV(patch.getCcCVV());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> repo.save(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从服务器删除数据"><a href="#从服务器删除数据" class="headerlink" title="从服务器删除数据"></a>从服务器删除数据</h3><p>使用 <code>@DeleteMapping</code> 声明处理 DELETE 请求的方法<br>使用 <code>@ResponseStatus</code> 声明响应的 HTTP 状态是 204（NO CONTENT）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseStatus(code=HttpStatus.NO_CONTENT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteOrder</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        repo.deleteById(orderId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EmptyResultDataAccessException e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启用超媒体"><a href="#启用超媒体" class="headerlink" title="启用超媒体"></a>启用超媒体</h2><h3 id="嵌套命名关系"><a href="#嵌套命名关系" class="headerlink" title="嵌套命名关系"></a>嵌套命名关系</h3><p><code>@Relation</code> 注解可以帮助打破 JSON 字段名与 Java 中定义的资源类型类名之间的耦合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Relation(value=&quot;taco&quot;, collectionRelation=&quot;tacos&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TacoResources</span> <span class="keyword">extends</span> <span class="title">ResourcesSupport</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="调用-REST-服务"><a href="#调用-REST-服务" class="headerlink" title="调用 REST 服务"></a>调用 REST 服务</h1><h2 id="使用-RestTemplate-调用-REST-端点"><a href="#使用-RestTemplate-调用-REST-端点" class="headerlink" title="使用 RestTemplate 调用 REST 端点"></a>使用 RestTemplate 调用 REST 端点</h2><p>RestTemplate 定义的 12 个唯一操作</p>
<ul>
<li>delete：执行 DELETE 请求</li>
<li>exchange：执行指定 HTTP 方法，返回 ResponseEntity</li>
<li>execute：执行指定的 HTTP 方法，返回一个映射到响应体的对象</li>
<li>getForEntity：发送 HTTP GET 方法，返回 ResponseEntity</li>
<li>getForObject：发送 HTTP GET 方法，返回对象</li>
<li>headForHeaders：发送 HTTP HEAD 请求，返回 HTTP 请求头</li>
<li>optionsForAllow：发送 HTTP OPTIONS 请求，返回 Allow 头信息</li>
<li>postForEntity：将数据 POST 到 URL，返回 ResponseEntity</li>
<li>postForLocation：将数据 POST 到 URL，返回新创建的 URL</li>
<li>postForObject：将数据 POST 到 URL，返回从响应主体映射的对象</li>
<li>put：将资源 PUT 到指定 URL</li>
</ul>
<p>通过 bean 指定注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请求-GET-资源"><a href="#请求-GET-资源" class="headerlink" title="请求 GET 资源"></a>请求 GET 资源</h3><p>使用 getForObject 方法<br>第一个参数为一个字符串，作为访问的 URL<br>第二个参数为响应应该反序列化的类型<br>第三个参数为绑定的对象（可使用 映射 Map 指定变量）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">getIngredientById</span><span class="params">(String ingredientId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rest.getForObject(<span class="string">&quot;http://localhost:8080/ingredients/&#123;id&#125;&quot;</span>,Ingredient.class, ingredientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 getForObject 方法，使用 URI 参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">getIngredientById</span><span class="params">(String ingredientId)</span> </span>&#123;</span><br><span class="line">    Map&lt;String,String&gt; urlVariables = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    urlVariables.put(<span class="string">&quot;id&quot;</span>, ingredientId);</span><br><span class="line">    URI url = UriComponentsBuilder</span><br><span class="line">        .fromHttpUrl(<span class="string">&quot;http://localhost:8080/ingredients/&#123;id&#125;&quot;</span>)</span><br><span class="line">        .build(urlVariables);</span><br><span class="line">    <span class="keyword">return</span> rest.getForObject(url, Ingredient.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getForEntity() 的工作方式与 getForObject() 非常相似，但它返回的不是表示响应有效负载的域对象，而是包装该域对象的 ResponseEntity 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">getIngredientById</span><span class="params">(String ingredientId)</span> </span>&#123;</span><br><span class="line">    ResponseEntity&lt;Ingredient&gt; responseEntity =</span><br><span class="line">        rest.getForEntity(<span class="string">&quot;http://localhost:8080/ingredients/&#123;id&#125;&quot;</span>,</span><br><span class="line">                          Ingredient.class, ingredientId);</span><br><span class="line">    log.info(<span class="string">&quot;Fetched time: &quot;</span> +</span><br><span class="line">             responseEntity.getHeaders().getDate());</span><br><span class="line">    <span class="keyword">return</span> responseEntity.getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请求-PUT-资源"><a href="#请求-PUT-资源" class="headerlink" title="请求 PUT 资源"></a>请求 PUT 资源</h3><p>对于发送 HTTP PUT 请求，提供 put 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">    rest.put(<span class="string">&quot;http://localhost:8080/ingredients/&#123;id&#125;&quot;</span>,</span><br><span class="line">            ingredient,</span><br><span class="line">            ingredient.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请求-DELETE-资源"><a href="#请求-DELETE-资源" class="headerlink" title="请求 DELETE 资源"></a>请求 DELETE 资源</h3><p>对于发送 HTTP DELETE 请求，提供 delete 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">    rest.delete(<span class="string">&quot;http://localhost:8080/ingredients/&#123;id&#125;&quot;</span>,</span><br><span class="line">               ingredient.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请求-POST-资源"><a href="#请求-POST-资源" class="headerlink" title="请求 POST 资源"></a>请求 POST 资源</h3><p>希望在 POST 请求后收到新创建的资源，可以使用 postForObject<br>第一个参数为 url<br>第二个参数为 发送的数据<br>第三个参数为 需要构造的对象类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">createIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rest.postForObject(<span class="string">&quot;http://localhost:8080/ingredients&quot;</span>,</span><br><span class="line">                             ingredient,</span><br><span class="line">                             Ingredient.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望在 POST 请求后收到新创建资源的位置，可以使用 postForLocation</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">createIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rest.postForLocation(<span class="string">&quot;http://localhost:8080/ingredients&quot;</span>,</span><br><span class="line">                                ingredient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要位置和响应负载，可以调用 postForEntity()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">createIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">    ResponseEntity&lt;Ingredient&gt; responseEntity =</span><br><span class="line">        rest.postForEntity(<span class="string">&quot;http://localhost:8080/ingredients&quot;</span>,</span><br><span class="line">                           ingredient,</span><br><span class="line">                           Ingredient.class);</span><br><span class="line">    </span><br><span class="line">    log.info(<span class="string">&quot;New resource created at &quot;</span> +</span><br><span class="line">             responseEntity.getHeaders().getLocation());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> responseEntity.getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-Traverson-引导-REST-API"><a href="#使用-Traverson-引导-REST-API" class="headerlink" title="使用 Traverson 引导 REST API"></a>使用 Traverson 引导 REST API</h2><p>进行 Traverson 的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Traverson traverson = <span class="keyword">new</span> Traverson(</span><br><span class="line">    URI.create(<span class="string">&quot;http://localhost:8080/api&quot;</span>), MediaType.HAL_JSON);</span><br></pre></td></tr></table></figure>

<p>调用 follow 方法，可以引导到链接关系名称的资源<br>调用 toObject 方法，来提取资源的内容（传入转换的对象类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ParameterizedTypeReference&lt;Resources&lt;Ingredient&gt;&gt; ingredientType =</span><br><span class="line">    <span class="keyword">new</span> ParameterizedTypeReference&lt;Resources&lt;Ingredient&gt;&gt;() &#123;&#125;;</span><br><span class="line">​</span><br><span class="line">Resources&lt;Ingredient&gt; ingredientRes =</span><br><span class="line">    traverson.follow(<span class="string">&quot;ingredients&quot;</span>).toObject(ingredientType);</span><br><span class="line">​</span><br><span class="line">Collection&lt;Ingredient&gt; ingredients = ingredientRes.getContent();</span><br></pre></td></tr></table></figure>

<h1 id="发送异步消息"><a href="#发送异步消息" class="headerlink" title="发送异步消息"></a>发送异步消息</h1><p>Spring 为异步消息传递提供了三个选项：<strong>JAVA 消息服务</strong>，<strong>RabbitMQ</strong>和高级消息队列协议、Apache Kafka</p>
<h2 id="使用-JMS-发送消息"><a href="#使用-JMS-发送消息" class="headerlink" title="使用 JMS 发送消息"></a>使用 JMS 发送消息</h2><p>JMS 是一个 Java 标准，定义了一个用于使用消息代理的公共 API。</p>
<h3 id="设置-JMS"><a href="#设置-JMS" class="headerlink" title="设置 JMS"></a>设置 JMS</h3><p>引用对应依赖，使用最新的 Apache ActiveMQ Artemis Broker</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-artemis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置代理属性</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">artemis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">//broker</span> <span class="string">主机</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">//broker</span> <span class="string">端口</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">//用户</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">//密码</span></span><br></pre></td></tr></table></figure>
<p>当 Broker 在本地运行时，都不需要为开发环境配置这些属性。</p>
<h3 id="使用-JmsTemplate-发送消息"><a href="#使用-JmsTemplate-发送消息" class="headerlink" title="使用 JmsTemplate 发送消息"></a>使用 JmsTemplate 发送消息</h3><p>JmsTemplate 是 Spring JMS 集成支持的核心。<br>JmsTemplate 专注于真正想做的事情：发送消息。<br>发送消息的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送原始消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(MessageCreator messageCreator)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Destination destination, MessageCreator messageCreator)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String destinationName, MessageCreator messageCreator)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="comment">// 发送转换自对象的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Destination destination, Object message)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String destinationName, Object message)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="comment">// 发送经过处理后从对象转换而来的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message, MessagePostProcessor postProcessor)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Destination destination, Object message, MessagePostProcessor postProcessor)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String destinationName, Object message, MessagePostProcessor postProcessor)</span> <span class="keyword">throws</span> JmsException</span>;</span><br></pre></td></tr></table></figure>

<p>实际上只有两个方法，send() 和 convertAndSend()，每个方法都被重载以支持不同的参数。如果仔细观察，会发现 convertAndSend() 的各种形式可以分为两个子类。</p>
<ul>
<li>send() 方法需要一个 MessageCreator 来制造一个 Message 对象。</li>
<li>convertAndSend() 方法接受一个 Object，并在后台自动将该 Object 转换为一条 Message。</li>
<li>三种 convertAndSend() 方法会自动将一个 Object 转换成一条 Message，但也会接受一个 MessagePostProcessor，以便在 Message 发送前对其进行定制。</li>
</ul>
<p>这三个方法类别中的每一个都由三个重载的方法组成，它们是通过指定 JMS 目的地（队列或主题）的方式来区分的：</p>
<ul>
<li>一个方法不接受目的地参数，并将消息发送到默认目的地。</li>
<li>一个方法接受指定消息目的地的目标对象。</li>
<li>一个方法接受一个 String，该 String 通过名称指定消息的目的地。</li>
</ul>
<p>使用 send 方法发送到默认目的地</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.messaging;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsOrderMessagingService</span> <span class="keyword">implements</span> <span class="title">OrderMessagingService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jms;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JmsOrderMessagingService</span><span class="params">(JmsTemplate jms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jms = jms;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        jms.send(session -&gt; session.createObjectMessage(order));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在 yml 配置默认地址</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jms:</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">default-destination:</span> <span class="string">tacocloud.order.queue</span></span><br></pre></td></tr></table></figure>

<p>或者通过 bean 的方式进行注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Destination <span class="title">orderQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(<span class="string">&quot;tacocloud.order.queue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 send 方法时，可用来指定目的地</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Destination orderQueue;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JmsOrderMessagingService</span><span class="params">(JmsTemplate jms, Destination orderQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.jms = jms;</span><br><span class="line">    <span class="keyword">this</span>.orderQueue = orderQueue;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    jms.send(</span><br><span class="line">        orderQueue,</span><br><span class="line">        session -&gt; session.createObjectMessage(order));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送前转换消息</strong><br>JmsTemplates 的 convertAndSend() 方法不需要提供 MessageCreator，从而简化了消息发布。<br>相反，将要直接发送的对象传递给 convertAndSend()，在发送之前会将该对象转换为消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    jms.convertAndSend(<span class="string">&quot;tacocloud.order.queue&quot;</span>, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-RabbitMQ-和-AMQP"><a href="#使用-RabbitMQ-和-AMQP" class="headerlink" title="使用 RabbitMQ 和 AMQP"></a>使用 RabbitMQ 和 AMQP</h2><p>添加 AMQP 依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加对应配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">rabbit.tacocloud.com</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5673</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">tacoweb</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">l3tm31n</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-RabbitTemplate-发送消息"><a href="#使用-RabbitTemplate-发送消息" class="headerlink" title="使用 RabbitTemplate 发送消息"></a>使用 RabbitTemplate 发送消息</h3><p>关于使用 RabbitTemplate 发送消息，send() 和 convertAndSend() 方法与来自 JmsTemplate 的同名方法并行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送原始消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 发送从对象转换过来的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey, Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 发送经过处理后从对象转换过来的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message, MessagePostProcessor mPP)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message, MessagePostProcessor messagePostProcessor)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey, Object message, MessagePostProcessor messagePostProcessor)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure>

<h3 id="从-RabbitMQ-接受消息"><a href="#从-RabbitMQ-接受消息" class="headerlink" title="从 RabbitMQ 接受消息"></a>从 RabbitMQ 接受消息</h3><p>与 JMS 一样，有两个选择：</p>
<ul>
<li>使用 RabbitTemplate 从队列中拉取消息</li>
<li>获取被推送到 @RabbitListener 注解的方法中的消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 接收从消息转换过来的对象</span></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 接收从消息转换过来的类型安全的对象</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(String queueName, ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(<span class="keyword">long</span> timeoutMillis, ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis, ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="使用-Kafka-发送消息"><a href="#使用-Kafka-发送消息" class="headerlink" title="使用 Kafka 发送消息"></a>使用 Kafka 发送消息</h2><p>Kafka 被设计为在集群中运行，提供了巨大的可伸缩性。通过将其 topic 划分到集群中的所有实例中，它具有很强的弹性。<br>RabbitMQ 主要处理 exchange 中的队列，而 Kafka 仅利用 topic 来提供消息的发布/订阅。</p>
<p>Kafka topic 被复制到集群中的所有 broker 中。集群中的每个节点充当一个或多个 topic 的 leader，负责该 topic 的数据并将其复制到集群中的其他节点。</p>
<h3 id="Spring-设置-Kafka"><a href="#Spring-设置-Kafka" class="headerlink" title="Spring 设置 Kafka"></a>Spring 设置 Kafka</h3><p>添加依赖，它的存在将触发 Kafka 的 Spring Boot 自动配置，它将在 Spring 应用程序上下文中生成一个 KafkaTemplate。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体来说就是，KafkaTemplate 默认在 localhost 上运行 Kafka broker，并监听 9092 端口。在开发应用程序时，在本地启动 Kafka broker 是可以的，但是在进入生产环境时，需要配置不同的主机和端口。</p>
<p>spring.kafka.bootstrap-servers 属性设置一个或多个 Kafka 服务器的位置，用于建立到 Kafka 集群的初始连接。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kafka.tacocloud.com:9092</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kafka.tacocloud.com:9093</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-KafkaTemplate-发送消息"><a href="#使用-KafkaTemplate-发送消息" class="headerlink" title="使用 KafkaTemplate 发送消息"></a>使用 KafkaTemplate 发送消息</h3><p>Kafka 发送消息的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, V data);</span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, K key, V data);</span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, Integer partition, K key, V data);</span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, Integer partition, Long timestamp, K key, V data);</span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(ProducerRecord&lt;K, V&gt; record);</span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(Message&lt;?&gt; message);</span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(V data);</span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(K key, V data);</span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(Integer partition, K key, V data);</span><br><span class="line">ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; sendDefault(Integer partition, Long timestamp, K key, V data);</span><br></pre></td></tr></table></figure>

<p>当使用 Kafka 发送消息时，可以指定以下参数来指导如何发送消息：</p>
<ul>
<li>发送消息的 topic（send() 方法必要的参数）</li>
<li>写入 topic 的分区（可选）</li>
<li>发送记录的键（可选）</li>
<li>时间戳（可选；默认为 System.currentTimeMillis()）</li>
<li>payload（必须）<br>topic 和 payload 是两个最重要的参数。</li>
</ul>
<p>简单实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.messaging;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaOrderMessagingService</span> <span class="keyword">implements</span> <span class="title">OrderMessagingService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, Order&gt; kafkaTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KafkaOrderMessagingService</span><span class="params">(KafkaTemplate&lt;String, Order&gt; kafkaTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        kafkaTemplate.send(<span class="string">&quot;tacocloud.orders.topic&quot;</span>, order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果设置了默认主题，可以稍微简化 sendOrder() 方法。<br>首先，通过设置 spring.kafka.template.default-topic 属性，将默认主题设置为 tacocloud.orders.topic</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">default-topic:</span> <span class="string">tacocloud.orders.topic</span></span><br></pre></td></tr></table></figure>

<p>然后，在 sendOrder() 方法中，可以调用 sendDefault() 而不是 send()，并且不指定主题名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    kafkaTemplate.sendDefault(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写-Kafka-监听器"><a href="#编写-Kafka-监听器" class="headerlink" title="编写 Kafka 监听器-"></a>编写 Kafka 监听器-</h3><p>KafkaTemplate 不提供任何接收消息的方法。<br>使用 Spring 消费来自 Kafka 主题的消息的唯一方法是编写消息监听器。<br>对于 Kafka，消息监听器被定义为被 @KafkaListener 注解的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.kitchen.messaging.kafka.listener;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line"><span class="keyword">import</span> tacos.kitchen.KitchenUI;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> KitchenUI ui;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderListener</span><span class="params">(KitchenUI ui)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ui = ui;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@KafkaListener(topics=&quot;tacocloud.orders.topic&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        ui.displayOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handle() 方法由 @KafkaListener 注解，表示当消息到达名为 tacocloud.orders.topic 的主题时应该调用它。</p>
<p>handle() 的以下实现接受一个 ConsumerRecord，这样就可以记录消息的分区和时间戳，可以使用 Message 而不是 ConsumerRecord，并达到同样的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(topics=&quot;tacocloud.orders.topic&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Order order, ConsumerRecord&lt;Order&gt; record)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;Received from partition &#123;&#125; with timestamp &#123;&#125;&quot;</span>,</span><br><span class="line">             record.partition(), record.timestamp());</span><br><span class="line">    ui.displayOrder(order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@KafkaListener(topics=&quot;tacocloud.orders.topic&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Order order, Message&lt;Order&gt; message)</span> </span>&#123;</span><br><span class="line">    MessageHeaders headers = message.getHeaders();</span><br><span class="line">    log.info(<span class="string">&quot;Received from partition &#123;&#125; with timestamp &#123;&#125;&quot;</span>,</span><br><span class="line">             headers.get(KafkaHeaders.RECEIVED_PARTITION_ID)</span><br><span class="line">             headers.get(KafkaHeaders.RECEIVED_TIMESTAMP));</span><br><span class="line">    ui.displayOrder(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集成-Spring"><a href="#集成-Spring" class="headerlink" title="集成 Spring"></a>集成 Spring</h1><h2 id="声明集成流"><a href="#声明集成流" class="headerlink" title="声明集成流"></a>声明集成流</h2><p>Spring Integration 支持创建集成流，通过集成流接受或发送数据到应用本身的外部数据<br>添加必要依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-integration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">​</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-integration-file<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来，需要为应用程序创建一种将数据发送到集成流的方法，以便将数据写入文件，声明网关接口</p>
<ul>
<li><code>@MessagingGateway</code> 表示，对接口的方法嗲用产生的信息都应该发送到给定的消息通道，<code>defaultRequestChannel</code> 指定通道</li>
<li><code>@Header</code> 表示，传递给 filename 的值应该放在消息头中，解析为 filename 的文件名<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.integration.annotation.MessagingGateway;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.file.FileHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Header;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@MessagingGateway(defaultRequestChannel=&quot;textInChannel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileWriterGateway</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Header(FileHeaders.FILENAME)</span> String filename,</span></span></span><br><span class="line"><span class="function"><span class="params">        String data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="在-Java-配置集成流"><a href="#在-Java-配置集成流" class="headerlink" title="在 Java 配置集成流"></a>在 Java 配置集成流</h3><p>声明两个 <code>bean</code>：一个转换器和一个文件写入消息处理器。</p>
<ul>
<li>转换器为 <code>GenericTransformer</code>，转换器的 <code>bean</code> 使用 <code>@Transformer</code> 注解，指定输入通道与输出通道</li>
<li>文件写入，使用 <code>@ServiceActivator</code> 进行注解，指定接收通道。<code>FileWritingMessageHandler</code> 是一个消息处理程序，它使用消息的 <code>file_name</code> 头中指定的文件名将消息有效负载写入指定目录中的文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.annotation.ServiceActivator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.annotation.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.file.FileWritingMessageHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.file.support.FileExistsMode;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.transformer.GenericTransformer;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterIntegrationConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Transformer(inputChannel=&quot;textInChannel&quot;, outputChannel=&quot;fileWriterChannel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GenericTransformer&lt;String, String&gt; <span class="title">upperCaseTransformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text -&gt; text.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel=&quot;fileWriterChannel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileWritingMessageHandler <span class="title">fileWriter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileWritingMessageHandler handler = </span><br><span class="line">            <span class="keyword">new</span> FileWritingMessageHandler(<span class="keyword">new</span> File(<span class="string">&quot;/tmp/sia5/files&quot;</span>));</span><br><span class="line">        handler.setExpectReply(<span class="keyword">false</span>);</span><br><span class="line">        handler.setFileExistsMode(FileExistsMode.APPEND);</span><br><span class="line">        handler.setAppendNewLine(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Spring-Integration-的-DSL-配置"><a href="#使用-Spring-Integration-的-DSL-配置" class="headerlink" title="使用 Spring Integration 的 DSL 配置"></a>使用 Spring Integration 的 DSL 配置</h3><p>直接声明一个定义整个流的 bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.dsl.IntegrationFlow;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.dsl.IntegrationFlows;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.dsl.channel.MessageChannels;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.file.dsl.Files;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.file.support.FileExistsMode;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterIntegrationConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntegrationFlow <span class="title">fileWriterFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IntegrationFlows</span><br><span class="line">            .from(MessageChannels.direct(<span class="string">&quot;textInChannel&quot;</span>))</span><br><span class="line">            .&lt;String, String&gt;transform(t -&gt; t.toUpperCase())</span><br><span class="line">            .handle(Files.outboundAdapter(<span class="keyword">new</span> File(<span class="string">&quot;/tmp/sia5/files&quot;</span>))</span><br><span class="line">                    .fileExistsMode(FileExistsMode.APPEND)</span><br><span class="line">                    .appendNewLine(<span class="keyword">true</span>))</span><br><span class="line">            .get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Integration"><a href="#Spring-Integration" class="headerlink" title="Spring Integration"></a>Spring Integration</h2><p>简要介绍组件</p>
<ul>
<li>Channels：消息管道</li>
<li>Filters：过滤器</li>
<li>Transformers：转换器</li>
<li>Routers：路由器</li>
<li>Splitters：分割器</li>
<li>Aggregators：聚合器</li>
<li>Service activators：消息处理器，并在输出通道发布返回值</li>
<li>Channel adapters：管道适配器</li>
<li>Gateways：网关接口</li>
</ul>
<h3 id="消息通道-Channels"><a href="#消息通道-Channels" class="headerlink" title="消息通道-Channels"></a>消息通道-Channels</h3><p>消息通道指消息移动的继承管道，Spring Integration 提供了多个管道的实现</p>
<ul>
<li>PublishSubscribeChannel：公开广播管道</li>
<li>QueueChannel：队列单播管道</li>
<li>PriorityChannel：优先级单播管道</li>
<li>DirectChannel：直连消息管道（与消费者同线程）</li>
</ul>
<p>在 Java 配置和 Java DSL 样式中，输入通道都是自动创建的，默认是 DirectChannel。<br>但是，如果希望使用不同的通道实现，则需要显式地将通道声明为 bean 并在集成流中引用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageChannel <span class="title">orderChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PublishSubscribeChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤器——filter"><a href="#过滤器——filter" class="headerlink" title="过滤器——filter"></a>过滤器——filter</h3><p>使用 filter 方法进行过滤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntegrationFlow <span class="title">evenNumberFlow</span><span class="params">(AtomicInteger integerSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IntegrationFlows</span><br><span class="line">        ...</span><br><span class="line">        .&lt;Integer&gt;filter((p) -&gt; p % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ...</span><br><span class="line">        .get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h3><p>通过 <code>@Transformer</code> 注解将 bean 指定为 transformer bean.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Transformer(inputChannel=&quot;numberChannel&quot;, outputChannel=&quot;romanNumberChannel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GenericTransformer&lt;Integer, String&gt; <span class="title">romanNumTransformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RomanNubers::toRoman;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于复杂的转换器，可以传递方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RomanNumberTransformer <span class="title">romanNumberTransformer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RomanNumberTransformer();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntegrationFlow <span class="title">transformerFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RomanNumberTransformer romanNumberTransformer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IntegrationFlows</span><br><span class="line">        ...</span><br><span class="line">        .transform(romanNumberTransformer)</span><br><span class="line">        ...</span><br><span class="line">        .get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>基于某些路由标准的路由器允许在集成流中进行分支，将消息定向到不同的通道。</p>
<p>例如，假设有一个名为 <code>numberChannel</code> 的通道，整数值通过它流动。假设希望将所有偶数消息定向到一个名为 <code>evenChannel</code> 的通道，而将奇数消息定向到一个名为 <code>oddChannel</code> 的通道。<br>要在集成流中创建这样的路由，可以声明一个 <code>AbstractMessageRouter</code> 类型的 <code>bean</code>，并使用 <code>@Router</code> 注解该 <code>bean</code></p>
<ul>
<li>AbstractMessageRouter bean 接受来自名为 numberChannel 的输入通道的消息</li>
<li>偶数，返回名为 evenChannel 的通道（在路由器 bean 之后声明为 bean）</li>
<li>奇数；返回名为 oddChannel 的通道（也在 bean 声明方法中声明）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Router(inputChannel=&quot;numberChannel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractMessageRouter <span class="title">evenOddRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractMessageRouter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Collection&lt;MessageChannel&gt;</span><br><span class="line">            determineTargetChannels(Message&lt;?&gt; message) &#123;</span><br><span class="line">            Integer number = (Integer) message.getPayload();</span><br><span class="line">            <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Collections.singleton(evenChannel());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Collections.singleton(oddChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageChannel <span class="title">evenChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectChannel();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageChannel <span class="title">oddChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分割器"><a href="#分割器" class="headerlink" title="分割器"></a>分割器</h3><p>使用 Splitter 的基本情况：</p>
<ul>
<li>消息有效载荷，包含单个消息有效载荷相同类型的项的集合。</li>
<li>信息有效载荷，携带的信息虽然相关，但可以分为两种或两种以上不同类型的信息。</li>
</ul>
<p>例如，假设希望将携带购买订单的消息拆分为两条消息：一条携带账单信息，另一条携带项目列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSplitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Object&gt; <span class="title">splitOrderIntoParts</span><span class="params">(PurchaseOrder po)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Object&gt; parts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        parts.add(po.getBillingInfo());</span><br><span class="line">        parts.add(po.getLineItems());</span><br><span class="line">        <span class="keyword">return</span> parts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@Splitter</code> 声明分割流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Splitter(inputChannel=&quot;poChannel&quot;, outputChannel=&quot;splitOrderChannel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderSplitter <span class="title">orderSplitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderSplitter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在流的这一点上，可以声明一个 PayloadTypeRouter 来将账单信息和项目，并路由到它们自己的子流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Router(inputChannel=&quot;splitOrderChannel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageRouter <span class="title">splitOrderRouter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PayloadTypeRouter router = <span class="keyword">new</span> PayloadTypeRouter();</span><br><span class="line">    router.setChannelMapping(</span><br><span class="line">        BillingInfo.class.getName(), <span class="string">&quot;billingInfoChannel&quot;</span>);</span><br><span class="line">    router.setChannelMapping(List.class.getName(), <span class="string">&quot;lineItemsChannel&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> router;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照目前的情况，流分为两个子流：一个是 BillingInfo 对象流，另一个是 <code>List&lt;LineItem&gt;</code> 流。但是，如果想进一步分割它，而不是处理 LineItem 列表，而是分别处理每个 LineItem</p>
<p>当携带 <code>List&lt;LineItem&gt;</code> 的有效负载的消息到达名为 lineItemsChannel 的通道时，它将传递到 lineItemSplitter() 方法。根据 Splitter 的规则，该方法必须返回要 Splitter 的项的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Splitter(inputChannel=&quot;lineItemsChannel&quot;, outputChannel=&quot;lineItemChannel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;LineItem&gt; <span class="title">lineItemSplitter</span><span class="params">(List&lt;LineItem&gt; lineItems)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lineItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务激活器"><a href="#服务激活器" class="headerlink" title="服务激活器"></a>服务激活器</h3><p>服务激活器从输入信道接收消息并发送这些消息给的 MessageHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ServiceActivator(inputChannel=&quot;someChannel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageHandler <span class="title">sysoutHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message payload: &quot;</span> + message.getPayload());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关是实现为应用程序可以调用将消息发送到集成信息流的接口。</p>
<h3 id="通道适配器"><a href="#通道适配器" class="headerlink" title="通道适配器"></a>通道适配器</h3><p>通道适配器代表集成信息流的入口点和出口点。数据通过入站信道适配器的方式进入到集成流中，通过出站信道适配器的方式离开集成流。</p>
<p>此 @Bean 方法声明了一个入站信道适配器 bean，后面跟随着 @InboundChannelAdapter 注解，它们每 1 秒（1000 ms）从注入的 AtomicInteger 提交一个数字到名 numberChannel 的通道中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@InboundChannelAdapter(</span></span><br><span class="line"><span class="meta">    poller=@Poller(fixedRate=&quot;1000&quot;), channel=&quot;numberChannel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource&lt;Integer&gt; <span class="title">numberSource</span><span class="params">(AtomicInteger source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericMessage&lt;&gt;(source.getAndIncrement());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建-Email-集成流"><a href="#创建-Email-集成流" class="headerlink" title="创建 Email 集成流"></a>创建 Email 集成流</h2><p>Taco Cloud 应该能让它的用户通过 email 提交他们的 taco 设计和放置订单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;tacocloud.email&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String mailbox;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> pollRate = <span class="number">30000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getImapUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;imaps://%s:%s@%s/%s&quot;</span>,</span><br><span class="line">             <span class="keyword">this</span>.username, <span class="keyword">this</span>.password, <span class="keyword">this</span>.host, <span class="keyword">this</span>.mailbox);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**yml 文件</span></span><br><span class="line"><span class="comment">tacocloud:</span></span><br><span class="line"><span class="comment">  email:</span></span><br><span class="line"><span class="comment">    host: imap.tacocloud.com</span></span><br><span class="line"><span class="comment">    mailbox: INBOX</span></span><br><span class="line"><span class="comment">    username: taco-in-flow</span></span><br><span class="line"><span class="comment">    password: 1L0v3T4c0s</span></span><br><span class="line"><span class="comment">    poll-rate: 10000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.dsl.IntegrationFlow;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.dsl.IntegrationFlows;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.dsl.Pollers;</span><br><span class="line">​</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TacoOrderEmailIntegrationConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntegrationFlow <span class="title">tacoOrderEmailFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        EmailProperties emailProps,</span></span></span><br><span class="line"><span class="function"><span class="params">        EmailToOrderTransformer emailToOrderTransformer,</span></span></span><br><span class="line"><span class="function"><span class="params">        OrderSubmitMessageHandler orderSubmitHandler)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> IntegrationFlows</span><br><span class="line">            .from(</span><br><span class="line">              Mail.imapInboundAdapter(emailProps.getImapUrl()),</span><br><span class="line">              e -&gt; e.poller(</span><br><span class="line">                  Pollers.fixedDelay(emailProps.getPollRate())))</span><br><span class="line">            .transform(emailToOrderTransformer)</span><br><span class="line">            .handle(orderSubmitHandler)</span><br><span class="line">            .get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>taco 订单电子邮件流（在 tacoOrderEmailFlow() 方法中的定义）是由三个不同的部分组成：</p>
<ul>
<li>IMAP 电子邮件入站信道适配器 —— 根据 EmailProperties 的 getImapUrl() 方法返回的 IMP URL 来创建通道适配器，根据 pollRate属性来设定轮询延时。进来的电子邮件被移交到它连接到转换器的通道。</li>
<li>一种将电子邮件转换为订单对象的转换器 —— 在 EmailToOrderTransformer 中实现的转换器，其被注入到 tacoOrderEmailFlow() 方法中。从转换中所产生的订单通过另外一个通道扇出到最终组件中。</li>
<li>处理程序（作为出站通道适配器）—— 处理程序接收一个订单对象，并将其提交到 Taco Cloud 的 REST API。</li>
</ul>

    </div>
     
    <div class="post-footer__meta">
    <p>
        updated at 2020-12-29
    </p>
</div> 
    <div class="post-meta__cats">
    
        <a href="/categories/spring/" class="post-cats__link button">spring</a>
    
    
</div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2021/01/07/interview-http/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            HTTP 发展历程
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2020/12/28/spring-async/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            关于-spring-异步操作的问题
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2020&nbsp;-&nbsp;2021 <a href="/">lianzixin</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

  



 


    
 

 

 

 




    </body>
</html>
